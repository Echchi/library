## **함수란**

**함수 : 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것**

``` javascript
// add : 함수이름
function add(x, y){ // x, y : 매개변수
 return x + y; // x + y : 반환값 
}

// 함수 호출
var result = add(2, 5) // 2, 5 : 인수
```

## **함수를 사용하는 이유**

-   **코드의 재사용 :** 동일한 작업을 반복적으로 수행해야 한다면 정의된 함수를 재사용하는 것이 효율적
-   **유지보수의 편의성과 코드의 신뢰성 증대 :** 중복된 코드 수정에 걸리는 시간과 실수 가능성 ↓ 재사용성 증대 ↑
-   **코드의 가독성 향상 :** 함수 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 도움

## **함수 리터럴**

**함수는 객체 타입의 값으로 객체를 객체 리터럴로 생성하는 것처럼 함수 역시 함수 리터럴로 생성 가능**

```javscript
// 변수에 "함수 리터럴"을 할당

var f = function add(x, y) {

  return x + y;

};
```

**함수는 객체지만 호출 가능하며 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 가짐 (일반 객체는 호출 불가능)**

**함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자**

**함수 정의**

**함수 정의 : 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들 그리고 반환할 값을 저장하는 것**

**정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 됨**

``` javascript
// 함수 선언문

function add(x,y){

 return x + y;

}



// 함수 표현식

var add = function(x,y){

 return x + y;

}



// Function 생성자 함수

var add = new Function('x', 'y', 'return x + y ');



// 화살표 함수

var add = (x, y) => x + y;
```

**변수는 선언하고 함수는 정의한다 (함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당)**

#### **함수 선언문**

-   함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름 생략 불가
-   함수 선언문은 표현식이 아닌 문

```javscript
// 함수 선언문

function add(x, y){

 return x + y;

}
```

#### **함수 선언문과 함수 리터럴 표현식의 차이**

**함수 리터럴 표현식**

``` javascript
// 함수 리터럴을 피연산자로 사용하면 함수 리터럴 표현식으로 해석

// 함수 이름 생략 가능

(function bar() {

  console.log("bar");

});

// 함수 이름 bar는 함수 몸체 내에서만 참조할 수 있는 식별자로 외부에서 함수 호출 불가

bar(); // ReferenceError: bar is not defined
```

**함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 → 함수 몸체 외부에서 함수 이름으로 참조 불가 → 함수를 가르키는 식별자 X**

**함수 선언문**

``` javascript
// 기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석

// 함수 이름 생략 불가

function foo() {

  console.log("foo"); 

}

// foo 는 자바스크립트 엔진이 암묵적으로 생성한 식별자

foo(); // foo
```

![function_1](https://github.com/Echchi/modernJS_deepDive/assets/112493260/196d0212-6a6d-4101-84da-15be4a8d925e)

**자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 거기에 함수 객체를 할당**

**함수 표현식**

**일급 객체 : 값의 성질을 갖는 객체** ( 자바스크립트의 함수는 일급 객체 )

**함수는 함수 객체를 가르키는 식별자로 호출됨**

``` javascript
// 기명 함수 표현식

var add = function foo (x, y){ // 첫번째 add 는 식별자, 두번째 foo 는 함수 이름

 return x + y;

};



// 함수 객체를 가르키는 식별자로 호출

console.log(add(2 , 5)); // 7 여기서의 add 는 식별자

// 함수 이름은 함수 몸체 내부에서만 유효한 식별자 

console.log(foo(2 , 5)); // ReferenceError : foo is not defined
```

**함수는 함수 이름으로 호출되는 것이 아니라 함수 객체를 가르키는 식별자로 호출함**

**함수 생성 시점과 함수 호이스팅**

``` javascript
// 함수 참조

console.dir(add); // f add(x , y)

console.dir(sub); // undefined



// 함수 호출

console.log(add(2, 5)); // 7

console.log(sub(2, 5)); // TypeError: sub is not a function



// 함수 선언문

function add(x, y){

 return x + y;

}



// 함수 표현식

var sub = function(x , y) {

 return x - y;

}
```

**함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름**

**함수 선언문으로 정의**

**런타임 이전에 함수 객체가 먼저 생성 → 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성 → 식별자를 생성된 함수 객체를 할당**

**함수 호이스팅 : 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징**

**변수 호이스팅 : var 키워드로 선언된 변수는 undefined로 초기화**

**함수 호이스팅 : 함수 객체로 초기화 (호출 가능)**

**함수 표현식으로 정의 (= 변수 선언문 방식과 동일하게 동작)**

**런타임 이전에 undefined 로 초기화 → 런타임에 할당문이 실행되는 시점에 평가되어 함수 객체가 됨**

**함수 표현식은 함수 호이스팅이 아닌 변수 호이스팅이 발생**

#### **Function 생성자 함수**

**생성자 함수 : 객체를 생성하는 함수**

var add = new Function('x', 'y', 'return x + y');

**Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는다**

#### **화살표 함수** 

``` javascript
const add = (x , y)=> x + y;
```

**화살표 함수는 항상 익명 함수( 함수 이름 생략) 로 정의**

## **함수 호출**

**함수를 가르키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출**

#### **매개변수와 인수**

**함수를 실행하기 위한 필요한 값을 함수 외부에서 내부로 전달할 필요가 있는 경우 매개변수를 통해 인수를 전달**

``` javascript
function add (x , y){ // x , y 매개변수

 return x + y; // 반환값

}

var result = add(2 , 5); // 2 , 5 인수
```

-   매개변수는 함수 몸체 내부에서 변수와 동일하게 취급
-   매개변수는 함수 몸체 내부에서만 참조 가능 ( 매개변수의 스코프는 함수 내부 )

``` javascript
function add(x, y) {

  console.log(x, y); // 2 3

  return x + y;

}



add(2, 3);

console.log(x); // ReferenceError: x is not defined



// 매개변수보다 인수가 적은 경우 할당되지 않은 매개변수 값 undefined

function add(x, y) {

  return x + y; // x : 2, y : undefined

}

add(2); // NaN



// 매개변수보다 인수가 더 많은 경우 arguments 에 보관

function add(x, y) {

  console.log(arguments); // [Arguments] { '0': 2, '1': 5, '2': 10 }

  return x + y;

}

add(2, 5, 10); // 7
```

#### **인수 확인**

-   자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 X
-   자바스크립트는 동적 타입언어로 매개변수의 타입을 사전에 지정할 수 X

**단축 평가로 매개변수에 기본값 할당**

``` javascript
function add(a, b, c) {

  a = a || 1;

  b = b || 1;

  c = c || 1;



  return a + b + c;

}

console.log(add(1, 2, 3)); // 6

console.log(add(1, 2)); // 3

console.log(add(1)); // 1

console.log(add()); // 1
```

**매개변수 기본값으로 인수체크 및 초기화 간소화**

``` javascript
function add(a = 0, b = 0) {

  return a - b;

}

console.log(add(1, 2)); // 3

console.log(add(1)); // 1

console.log(add()); // 0
```

**매개변수의 최대 개수**

**이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 함**

**매개변수는 최대 3개 이상을 넘지 않는 것을 권장**

**객체를 인수로 사용하는 경우 프로퍼티 키만 정확히 지정하면 코드 가독성 증대 및 실수 감소**

**반환문**

-   반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나감 
-   return 키워드 뒤에 오는 표현식을 평가해 반환 (생략하면 undefined 반환)

## **참조에 의한 전달과 외부 상태의 변경**

**값에 의한 호출** (= call by value)

매개변수가 원시타입일 경우 **값 자체가 복사**되어 매개변수에 전달되기 때문에 **원본은 변경 불가능**하며 재할당을 통해 할당된 원시 값은 새로운 원시 값으로 교체 (원본 훼손 X)

**참조에 의한 호출** (=call by reference)

매개변수가 객체일 경우 값이 아닌 **참조 값이 복사**되어 매개변수에 전달되기 때문에 직접 변경 가능하며 재할당 없이 **직접 할당된 객체를 변경** (원본 훼손)

## **다양한 함수의 형태**

**즉시 실행 함수 : 함수 정의와 동시에 즉시 호출되는 함수** (단 한번만 호출되며 재호출 불가)

``` javascript
// 익명 즉시 실행 함수

(function(){

 var a = 3;

 var b = 5;

 return a * b;

}());



// 기명 즉시 실행 함수

(function foo(){

 var a = 3;

 var b = 5;

 return a * b;

}());



// 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자로 즉시 실행 함수 재호출 불가

foo(); // ReferenceError
```

**재귀 함수 :  함수가 자기 자신을 호출하는 것** ( 반드시 탈출 조건 필요 )

console.log(factorial(5)) _// 5! = 5 \* 4 \* 3 \* 2 \* 1 = 120_

**factorial 함수 내부에서 자기 자신을 호출할 때 사용한 식별자 foo 은 함수 이름으로 함수 몸체 내부에서만 유효**

**함수 외부에서 함수를 호출할 때는 반드시 함수를 가르키는 식별자 factorial로 해야함**

**중첩 함수 : 함수 내부에 정의된 함수 (= 내부함수)**

**외부 함수 : 중첩 함수를 포함하는 함수**

``` javascript
// 외부 함수

function outer(){

 var x = 1;

 

  // 중첩 함수

  function inner(){

  var y = 2;

    // 외부 함수 변수 참조 가능 

    console.log(x + y) // 3 

  }

}
```

**콜백함수 : 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수**

**고차함수 : 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수**

-   고차함수는 콜백 함수를 자신의 일부분으로 합성
-   고차함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출
-   콜백 함수는 고차 함수에 의해 호출되며 이때 고차 함수는 필요에 따라 콜백 함수에 인수 전달 가능

``` javascript
// 외부에서 전달받은 func 를 n 만큼 반복 호출

function repeat(n, f) {

  for (var i = 0; i < n; i++) {

    f(i);

  }

}



// 콜백 함수

var logAll = function (i) {

  console.log(i);

};



// 반복 호출할 함수를 인수로 전달

repeat(5, logAll); // 0 1 2 3 4



// 콜백 함수

var logOdd = function (i) {

  if (i % 2) console.log(i);

};



// 반복 호출할 함수를 인수로 전달

repeat(5, logOdd); // 1 3



// 익명 함수 리터럴을 콜백 함수로 고차 함수에 전달

// 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체 생성

repeat( 5 , function(i){

 if( i % 2 ) console.log(i);

}); // 1 3
```

**순수 함수 : 어떤 외부 상태에도 의존하지 않고 변경하지도 않는 부수효과가 없는 함수**

-   동일한 인수가 전달되면 언제나 동일한 값을 반환
-   최소 하나 이상의 인수를 전달 받음
-   외부 상태를 변경하지 않음

``` javascript
var count = 0;

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환

function increase(n){

 return ++n;

}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태를 변경

count = increase(count);

console.log(count); // 1
```

**비순수 함수 : 외부 상태에 의존하거나 외부 상태를 변경하는 부수 효과가 있는 함수**

``` javascript
var count = 0; // 현재 카운트를 나타내는 상태 : increase 함수에 의해 변화

// 비순수 함수

function increase(){

 return ++count; // 외부 상태에 의존하며 외부 상태를 변경

}

// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워짐

increase();

console.log(count); // 1
```

**함수형 프로그래밍**

-   순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화하여 불변성을 지향하는 프로그래밍 패러다임
-   로직 내에 존재하는 조건문과 반복문을 제거해서 복잡성 해결
-   변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류 최소화
